coverage:
  all_nodes: 6759
  covered_nodes: 5205
mutation_score: 100.0
mutations:
- exception_traceback: "mocker = <pytest_mock.plugin.MockFixture object at 0x7facec626cd0>\n\
    cli_runner = <function cli_runner.<locals>.cli_main at 0x7facec384dc0>\n\n   \
    \ @pytest.mark.usefixtures('remove_fake_project_dir')\n    def test_cli_replay(mocker,\
    \ cli_runner):\n        \"\"\"Test cli invocation display log with `verbose` and\
    \ `replay` flags.\"\"\"\n        mock_cookiecutter = mocker.patch('cookiecutter.cli.cookiecutter')\n\
    \    \n        template_path = 'tests/fake-repo-pre/'\n        result = cli_runner(template_path,\
    \ '--replay', '-v')\n    \n        assert result.exit_code == 0\n>       mock_cookiecutter.assert_called_once_with(\n\
    \            template_path,\n            None,\n            False,\n         \
    \   replay=True,\n            overwrite_if_exists=False,\n            skip_if_file_exists=False,\n\
    \            output_dir='.',\n            config_file=None,\n            default_config=False,\n\
    \            extra_context=None,\n            password=None,\n            directory=None,\n\
    \            accept_hooks=True,\n        )\nE       AssertionError: Expected 'cookiecutter'\
    \ to be called once. Called 0 times.\n\ntests/test_cli.py:95: AssertionError"
  killer: tests/test_cli.py::test_cli_replay
  module: !!python/module:cookiecutter.environment ''
  mutations:
  - lineno: 59
    operator: IOP
  number: 1
  status: killed
  tests_run: 47
  time: 2.319603681564331
- exception_traceback: "script_path = '/tmp/tmpk6163q1a.sh', cwd = '/usr/baki/python_projects/cookiecutter/inputshellhooks'\n\
    \n    def run_script(script_path, cwd='.'):\n        \"\"\"Execute a script from\
    \ a working directory.\n    \n        :param script_path: Absolute path to the\
    \ script to run.\n        :param cwd: The directory to run the script from.\n\
    \        \"\"\"\n        run_thru_shell = sys.platform.startswith('win')\n   \
    \     if script_path.endswith('.py'):\n            script_command = [sys.executable,\
    \ script_path]\n        else:\n            script_command = [script_path]\n  \
    \  \n        utils.make_executable(script_path)\n    \n        try:\n>       \
    \    proc = subprocess.Popen(script_command, shell=run_thru_shell, cwd=cwd)\n\n\
    cookiecutter/hooks.py:82: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
    \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself\
    \ = <subprocess.Popen object at 0x7facebdd6c10>, args = ['/tmp/tmpk6163q1a.sh'],\
    \ bufsize = -1, executable = None\nstdin = None, stdout = None, stderr = None,\
    \ preexec_fn = None, close_fds = True, shell = False\ncwd = '/usr/baki/python_projects/cookiecutter/inputshellhooks',\
    \ env = None, universal_newlines = None\nstartupinfo = None, creationflags = 0,\
    \ restore_signals = True, start_new_session = False, pass_fds = ()\n\n    def\
    \ __init__(self, args, bufsize=-1, executable=None,\n                 stdin=None,\
    \ stdout=None, stderr=None,\n                 preexec_fn=None, close_fds=True,\n\
    \                 shell=False, cwd=None, env=None, universal_newlines=None,\n\
    \                 startupinfo=None, creationflags=0,\n                 restore_signals=True,\
    \ start_new_session=False,\n                 pass_fds=(), *, encoding=None, errors=None,\
    \ text=None):\n        \"\"\"Create new Popen instance.\"\"\"\n        _cleanup()\n\
    \        # Held while anything is calling waitpid before returncode has been\n\
    \        # updated to prevent clobbering returncode if wait() or poll() are\n\
    \        # called from multiple threads at once.  After acquiring the lock,\n\
    \        # code must re-check self.returncode to see if another thread just\n\
    \        # finished a waitpid() call.\n        self._waitpid_lock = threading.Lock()\n\
    \    \n        self._input = None\n        self._communication_started = False\n\
    \        if bufsize is None:\n            bufsize = -1  # Restore default\n  \
    \      if not isinstance(bufsize, int):\n            raise TypeError(\"bufsize\
    \ must be an integer\")\n    \n        if _mswindows:\n            if preexec_fn\
    \ is not None:\n                raise ValueError(\"preexec_fn is not supported\
    \ on Windows \"\n                                 \"platforms\")\n        else:\n\
    \            # POSIX\n            if pass_fds and not close_fds:\n           \
    \     warnings.warn(\"pass_fds overriding close_fds.\", RuntimeWarning)\n    \
    \            close_fds = True\n            if startupinfo is not None:\n     \
    \           raise ValueError(\"startupinfo is only supported on Windows \"\n \
    \                                \"platforms\")\n            if creationflags\
    \ != 0:\n                raise ValueError(\"creationflags is only supported on\
    \ Windows \"\n                                 \"platforms\")\n    \n        self.args\
    \ = args\n        self.stdin = None\n        self.stdout = None\n        self.stderr\
    \ = None\n        self.pid = None\n        self.returncode = None\n        self.encoding\
    \ = encoding\n        self.errors = errors\n    \n        # Validate the combinations\
    \ of text and universal_newlines\n        if (text is not None and universal_newlines\
    \ is not None\n            and bool(universal_newlines) != bool(text)):\n    \
    \        raise SubprocessError('Cannot disambiguate when both text '\n       \
    \                           'and universal_newlines are supplied but '\n     \
    \                             'different. Pass one or the other.')\n    \n   \
    \     # Input and output objects. The general principle is like\n        # this:\n\
    \        #\n        # Parent                   Child\n        # ------       \
    \            -----\n        # p2cwrite   ---stdin--->  p2cread\n        # c2pread\
    \    <--stdout---  c2pwrite\n        # errread    <--stderr---  errwrite\n   \
    \     #\n        # On POSIX, the child objects are file descriptors.  On\n   \
    \     # Windows, these are Windows file handles.  The parent objects\n       \
    \ # are file descriptors on both platforms.  The parent objects\n        # are\
    \ -1 when not using PIPEs. The child objects are -1\n        # when not redirecting.\n\
    \    \n        (p2cread, p2cwrite,\n         c2pread, c2pwrite,\n         errread,\
    \ errwrite) = self._get_handles(stdin, stdout, stderr)\n    \n        # We wrap\
    \ OS handles *before* launching the child, otherwise a\n        # quickly terminating\
    \ child could make our fds unwrappable\n        # (see #8458).\n    \n       \
    \ if _mswindows:\n            if p2cwrite != -1:\n                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(),\
    \ 0)\n            if c2pread != -1:\n                c2pread = msvcrt.open_osfhandle(c2pread.Detach(),\
    \ 0)\n            if errread != -1:\n                errread = msvcrt.open_osfhandle(errread.Detach(),\
    \ 0)\n    \n        self.text_mode = encoding or errors or text or universal_newlines\n\
    \    \n        # How long to resume waiting on a child after the first ^C.\n \
    \       # There is no right value for this.  The purpose is to be polite\n   \
    \     # yet remain good for interactive users trying to exit a tool.\n       \
    \ self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()\n    \n       \
    \ self._closed_child_pipe_fds = False\n    \n        if self.text_mode:\n    \
    \        if bufsize == 1:\n                line_buffering = True\n           \
    \     # Use the default buffer size for the underlying binary streams\n      \
    \          # since they don't support line buffering.\n                bufsize\
    \ = -1\n            else:\n                line_buffering = False\n    \n    \
    \    try:\n            if p2cwrite != -1:\n                self.stdin = io.open(p2cwrite,\
    \ 'wb', bufsize)\n                if self.text_mode:\n                    self.stdin\
    \ = io.TextIOWrapper(self.stdin, write_through=True,\n                       \
    \     line_buffering=line_buffering,\n                            encoding=encoding,\
    \ errors=errors)\n            if c2pread != -1:\n                self.stdout =\
    \ io.open(c2pread, 'rb', bufsize)\n                if self.text_mode:\n      \
    \              self.stdout = io.TextIOWrapper(self.stdout,\n                 \
    \           encoding=encoding, errors=errors)\n            if errread != -1:\n\
    \                self.stderr = io.open(errread, 'rb', bufsize)\n             \
    \   if self.text_mode:\n                    self.stderr = io.TextIOWrapper(self.stderr,\n\
    \                            encoding=encoding, errors=errors)\n    \n>      \
    \     self._execute_child(args, executable, preexec_fn, close_fds,\n         \
    \                       pass_fds, cwd, env,\n                                startupinfo,\
    \ creationflags, shell,\n                                p2cread, p2cwrite,\n\
    \                                c2pread, c2pwrite,\n                        \
    \        errread, errwrite,\n                                restore_signals,\
    \ start_new_session)\n\n/usr/lib/python3.8/subprocess.py:854: \n_ _ _ _ _ _ _\
    \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
    \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <subprocess.Popen object at 0x7facebdd6c10>,\
    \ args = ['/tmp/tmpk6163q1a.sh']\nexecutable = b'/tmp/tmpk6163q1a.sh', preexec_fn\
    \ = None, close_fds = True, pass_fds = ()\ncwd = '/usr/baki/python_projects/cookiecutter/inputshellhooks',\
    \ env = None, startupinfo = None, creationflags = 0\nshell = False, p2cread =\
    \ -1, p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1\n\
    restore_signals = True, start_new_session = False\n\n    def _execute_child(self,\
    \ args, executable, preexec_fn, close_fds,\n                       pass_fds, cwd,\
    \ env,\n                       startupinfo, creationflags, shell,\n          \
    \             p2cread, p2cwrite,\n                       c2pread, c2pwrite,\n\
    \                       errread, errwrite,\n                       restore_signals,\
    \ start_new_session):\n        \"\"\"Execute program (POSIX version)\"\"\"\n \
    \   \n        if isinstance(args, (str, bytes)):\n            args = [args]\n\
    \        elif isinstance(args, os.PathLike):\n            if shell:\n        \
    \        raise TypeError('path-like args is not allowed when '\n             \
    \                   'shell is true')\n            args = [args]\n        else:\n\
    \            args = list(args)\n    \n        if shell:\n            # On Android\
    \ the default shell is at '/system/bin/sh'.\n            unix_shell = ('/system/bin/sh'\
    \ if\n                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')\n\
    \            args = [unix_shell, \"-c\"] + args\n            if executable:\n\
    \                args[0] = executable\n    \n        if executable is None:\n\
    \            executable = args[0]\n    \n        sys.audit(\"subprocess.Popen\"\
    , executable, args, cwd, env)\n    \n        if (_USE_POSIX_SPAWN\n          \
    \      and os.path.dirname(executable)\n                and preexec_fn is None\n\
    \                and not close_fds\n                and not pass_fds\n       \
    \         and cwd is None\n                and (p2cread == -1 or p2cread > 2)\n\
    \                and (c2pwrite == -1 or c2pwrite > 2)\n                and (errwrite\
    \ == -1 or errwrite > 2)\n                and not start_new_session):\n      \
    \      self._posix_spawn(args, executable, env, restore_signals,\n           \
    \                   p2cread, p2cwrite,\n                              c2pread,\
    \ c2pwrite,\n                              errread, errwrite)\n            return\n\
    \    \n        orig_executable = executable\n    \n        # For transferring\
    \ possible exec failure from child to parent.\n        # Data format: \"exception\
    \ name:hex errno:description\"\n        # Pickle is not used; it is complex and\
    \ involves memory allocation.\n        errpipe_read, errpipe_write = os.pipe()\n\
    \        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.\n\
    \        low_fds_to_close = []\n        while errpipe_write < 3:\n           \
    \ low_fds_to_close.append(errpipe_write)\n            errpipe_write = os.dup(errpipe_write)\n\
    \        for low_fd in low_fds_to_close:\n            os.close(low_fd)\n     \
    \   try:\n            try:\n                # We must avoid complex work that\
    \ could involve\n                # malloc or free in the child process to avoid\n\
    \                # potential deadlocks, thus we do all this here.\n          \
    \      # and pass it to fork_exec()\n    \n                if env is not None:\n\
    \                    env_list = []\n                    for k, v in env.items():\n\
    \                        k = os.fsencode(k)\n                        if b'=' in\
    \ k:\n                            raise ValueError(\"illegal environment variable\
    \ name\")\n                        env_list.append(k + b'=' + os.fsencode(v))\n\
    \                else:\n                    env_list = None  # Use execv instead\
    \ of execve.\n                executable = os.fsencode(executable)\n         \
    \       if os.path.dirname(executable):\n                    executable_list =\
    \ (executable,)\n                else:\n                    # This matches the\
    \ behavior of os._execvpe().\n                    executable_list = tuple(\n \
    \                       os.path.join(os.fsencode(dir), executable)\n         \
    \               for dir in os.get_exec_path(env))\n                fds_to_keep\
    \ = set(pass_fds)\n                fds_to_keep.add(errpipe_write)\n          \
    \      self.pid = _posixsubprocess.fork_exec(\n                        args, executable_list,\n\
    \                        close_fds, tuple(sorted(map(int, fds_to_keep))),\n  \
    \                      cwd, env_list,\n                        p2cread, p2cwrite,\
    \ c2pread, c2pwrite,\n                        errread, errwrite,\n           \
    \             errpipe_read, errpipe_write,\n                        restore_signals,\
    \ start_new_session, preexec_fn)\n                self._child_created = True\n\
    \            finally:\n                # be sure the FD is closed no matter what\n\
    \                os.close(errpipe_write)\n    \n            self._close_pipe_fds(p2cread,\
    \ p2cwrite,\n                                 c2pread, c2pwrite,\n           \
    \                      errread, errwrite)\n    \n            # Wait for exec to\
    \ fail or succeed; possibly raising an\n            # exception (limited in size)\n\
    \            errpipe_data = bytearray()\n            while True:\n           \
    \     part = os.read(errpipe_read, 50000)\n                errpipe_data += part\n\
    \                if not part or len(errpipe_data) > 50000:\n                 \
    \   break\n        finally:\n            # be sure the FD is closed no matter\
    \ what\n            os.close(errpipe_read)\n    \n        if errpipe_data:\n \
    \           try:\n                pid, sts = os.waitpid(self.pid, 0)\n       \
    \         if pid == self.pid:\n                    self._handle_exitstatus(sts)\n\
    \                else:\n                    self.returncode = sys.maxsize\n  \
    \          except ChildProcessError:\n                pass\n    \n           \
    \ try:\n                exception_name, hex_errno, err_msg = (\n             \
    \           errpipe_data.split(b':', 2))\n                # The encoding here\
    \ should match the encoding\n                # written in by the subprocess implementations\n\
    \                # like _posixsubprocess\n                err_msg = err_msg.decode()\n\
    \            except ValueError:\n                exception_name = b'SubprocessError'\n\
    \                hex_errno = b'0'\n                err_msg = 'Bad exception data\
    \ from child: {!r}'.format(\n                              bytes(errpipe_data))\n\
    \            child_exception_type = getattr(\n                    builtins, exception_name.decode('ascii'),\n\
    \                    SubprocessError)\n            if issubclass(child_exception_type,\
    \ OSError) and hex_errno:\n                errno_num = int(hex_errno, 16)\n  \
    \              child_exec_never_called = (err_msg == \"noexec\")\n           \
    \     if child_exec_never_called:\n                    err_msg = \"\"\n      \
    \              # The error must be from chdir(cwd).\n                    err_filename\
    \ = cwd\n                else:\n                    err_filename = orig_executable\n\
    \                if errno_num != 0:\n                    err_msg = os.strerror(errno_num)\n\
    >               raise child_exception_type(errno_num, err_msg, err_filename)\n\
    E               OSError: [Errno 8] Exec format error: '/tmp/tmpk6163q1a.sh'\n\n\
    /usr/lib/python3.8/subprocess.py:1702: OSError\n\nDuring handling of the above\
    \ exception, another exception occurred:\n\n    @pytest.mark.skipif(WINDOWS, reason='OSError.errno=8\
    \ is not thrown on Windows')\n    @pytest.mark.usefixtures('clean_system', 'remove_additional_folders')\n\
    \    def test_empty_hooks():\n        \"\"\"Verify error is raised on empty hook\
    \ script. Ignored on windows.\n    \n        OSError.errno=8 is not thrown on\
    \ Windows when the script is empty\n        because it always runs through shell\
    \ instead of needing a shebang.\n        \"\"\"\n        with pytest.raises(FailedHookException)\
    \ as excinfo:\n>           generate.generate_files(\n                context={'cookiecutter':\
    \ {'shellhooks': 'shellhooks'}},\n                repo_dir='tests/test-shellhooks-empty/',\n\
    \                overwrite_if_exists=True,\n            )\n\ntests/test_generate_hooks.py:80:\
    \ \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
    \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/generate.py:304:\
    \ in generate_files\n    _run_hook_from_repo_dir(\ncookiecutter/generate.py:243:\
    \ in _run_hook_from_repo_dir\n    run_hook(hook_name, project_dir, context)\n\
    cookiecutter/hooks.py:131: in run_hook\n    run_script_with_context(script, project_dir,\
    \ context)\ncookiecutter/hooks.py:114: in run_script_with_context\n    run_script(temp.name,\
    \ cwd)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
    \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nscript_path = '/tmp/tmpk6163q1a.sh',\
    \ cwd = '/usr/baki/python_projects/cookiecutter/inputshellhooks'\n\n    def run_script(script_path,\
    \ cwd='.'):\n        \"\"\"Execute a script from a working directory.\n    \n\
    \        :param script_path: Absolute path to the script to run.\n        :param\
    \ cwd: The directory to run the script from.\n        \"\"\"\n        run_thru_shell\
    \ = sys.platform.startswith('win')\n        if script_path.endswith('.py'):\n\
    \            script_command = [sys.executable, script_path]\n        else:\n \
    \           script_command = [script_path]\n    \n        utils.make_executable(script_path)\n\
    \    \n        try:\n            proc = subprocess.Popen(script_command, shell=run_thru_shell,\
    \ cwd=cwd)\n            exit_status = proc.wait()\n            if exit_status\
    \ != EXIT_SUCCESS:\n                raise FailedHookException(\n             \
    \       'Hook script failed (exit status: {})'.format(exit_status)\n         \
    \       )\n        except OSError as os_error:\n            if os_error.errno\
    \ == errno.ENOEXEC:\n>               raise FailedHookException(\n            \
    \        'Hook script failed, might be an empty file or missing a shebang'\n \
    \               )\nE               cookiecutter.exceptions.FailedHookException:\
    \ Hook script failed, might be an empty file or missing a shebang\n\ncookiecutter/hooks.py:90:\
    \ FailedHookException"
  killer: tests/test_generate_hooks.py::test_empty_hooks
  module: &id001 !!python/module:cookiecutter.extensions ''
  mutations:
  - lineno: 13
    operator: IOP
  number: 2
  status: killed
  tests_run: 4
  time: 1.5247132778167725
- exception_traceback: "script_path = '/tmp/tmp884gpyrt.sh', cwd = '/usr/baki/python_projects/cookiecutter/inputshellhooks'\n\
    \n    def run_script(script_path, cwd='.'):\n        \"\"\"Execute a script from\
    \ a working directory.\n    \n        :param script_path: Absolute path to the\
    \ script to run.\n        :param cwd: The directory to run the script from.\n\
    \        \"\"\"\n        run_thru_shell = sys.platform.startswith('win')\n   \
    \     if script_path.endswith('.py'):\n            script_command = [sys.executable,\
    \ script_path]\n        else:\n            script_command = [script_path]\n  \
    \  \n        utils.make_executable(script_path)\n    \n        try:\n>       \
    \    proc = subprocess.Popen(script_command, shell=run_thru_shell, cwd=cwd)\n\n\
    cookiecutter/hooks.py:82: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
    \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself\
    \ = <subprocess.Popen object at 0x7facec3bac40>, args = ['/tmp/tmp884gpyrt.sh'],\
    \ bufsize = -1, executable = None\nstdin = None, stdout = None, stderr = None,\
    \ preexec_fn = None, close_fds = True, shell = False\ncwd = '/usr/baki/python_projects/cookiecutter/inputshellhooks',\
    \ env = None, universal_newlines = None\nstartupinfo = None, creationflags = 0,\
    \ restore_signals = True, start_new_session = False, pass_fds = ()\n\n    def\
    \ __init__(self, args, bufsize=-1, executable=None,\n                 stdin=None,\
    \ stdout=None, stderr=None,\n                 preexec_fn=None, close_fds=True,\n\
    \                 shell=False, cwd=None, env=None, universal_newlines=None,\n\
    \                 startupinfo=None, creationflags=0,\n                 restore_signals=True,\
    \ start_new_session=False,\n                 pass_fds=(), *, encoding=None, errors=None,\
    \ text=None):\n        \"\"\"Create new Popen instance.\"\"\"\n        _cleanup()\n\
    \        # Held while anything is calling waitpid before returncode has been\n\
    \        # updated to prevent clobbering returncode if wait() or poll() are\n\
    \        # called from multiple threads at once.  After acquiring the lock,\n\
    \        # code must re-check self.returncode to see if another thread just\n\
    \        # finished a waitpid() call.\n        self._waitpid_lock = threading.Lock()\n\
    \    \n        self._input = None\n        self._communication_started = False\n\
    \        if bufsize is None:\n            bufsize = -1  # Restore default\n  \
    \      if not isinstance(bufsize, int):\n            raise TypeError(\"bufsize\
    \ must be an integer\")\n    \n        if _mswindows:\n            if preexec_fn\
    \ is not None:\n                raise ValueError(\"preexec_fn is not supported\
    \ on Windows \"\n                                 \"platforms\")\n        else:\n\
    \            # POSIX\n            if pass_fds and not close_fds:\n           \
    \     warnings.warn(\"pass_fds overriding close_fds.\", RuntimeWarning)\n    \
    \            close_fds = True\n            if startupinfo is not None:\n     \
    \           raise ValueError(\"startupinfo is only supported on Windows \"\n \
    \                                \"platforms\")\n            if creationflags\
    \ != 0:\n                raise ValueError(\"creationflags is only supported on\
    \ Windows \"\n                                 \"platforms\")\n    \n        self.args\
    \ = args\n        self.stdin = None\n        self.stdout = None\n        self.stderr\
    \ = None\n        self.pid = None\n        self.returncode = None\n        self.encoding\
    \ = encoding\n        self.errors = errors\n    \n        # Validate the combinations\
    \ of text and universal_newlines\n        if (text is not None and universal_newlines\
    \ is not None\n            and bool(universal_newlines) != bool(text)):\n    \
    \        raise SubprocessError('Cannot disambiguate when both text '\n       \
    \                           'and universal_newlines are supplied but '\n     \
    \                             'different. Pass one or the other.')\n    \n   \
    \     # Input and output objects. The general principle is like\n        # this:\n\
    \        #\n        # Parent                   Child\n        # ------       \
    \            -----\n        # p2cwrite   ---stdin--->  p2cread\n        # c2pread\
    \    <--stdout---  c2pwrite\n        # errread    <--stderr---  errwrite\n   \
    \     #\n        # On POSIX, the child objects are file descriptors.  On\n   \
    \     # Windows, these are Windows file handles.  The parent objects\n       \
    \ # are file descriptors on both platforms.  The parent objects\n        # are\
    \ -1 when not using PIPEs. The child objects are -1\n        # when not redirecting.\n\
    \    \n        (p2cread, p2cwrite,\n         c2pread, c2pwrite,\n         errread,\
    \ errwrite) = self._get_handles(stdin, stdout, stderr)\n    \n        # We wrap\
    \ OS handles *before* launching the child, otherwise a\n        # quickly terminating\
    \ child could make our fds unwrappable\n        # (see #8458).\n    \n       \
    \ if _mswindows:\n            if p2cwrite != -1:\n                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(),\
    \ 0)\n            if c2pread != -1:\n                c2pread = msvcrt.open_osfhandle(c2pread.Detach(),\
    \ 0)\n            if errread != -1:\n                errread = msvcrt.open_osfhandle(errread.Detach(),\
    \ 0)\n    \n        self.text_mode = encoding or errors or text or universal_newlines\n\
    \    \n        # How long to resume waiting on a child after the first ^C.\n \
    \       # There is no right value for this.  The purpose is to be polite\n   \
    \     # yet remain good for interactive users trying to exit a tool.\n       \
    \ self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()\n    \n       \
    \ self._closed_child_pipe_fds = False\n    \n        if self.text_mode:\n    \
    \        if bufsize == 1:\n                line_buffering = True\n           \
    \     # Use the default buffer size for the underlying binary streams\n      \
    \          # since they don't support line buffering.\n                bufsize\
    \ = -1\n            else:\n                line_buffering = False\n    \n    \
    \    try:\n            if p2cwrite != -1:\n                self.stdin = io.open(p2cwrite,\
    \ 'wb', bufsize)\n                if self.text_mode:\n                    self.stdin\
    \ = io.TextIOWrapper(self.stdin, write_through=True,\n                       \
    \     line_buffering=line_buffering,\n                            encoding=encoding,\
    \ errors=errors)\n            if c2pread != -1:\n                self.stdout =\
    \ io.open(c2pread, 'rb', bufsize)\n                if self.text_mode:\n      \
    \              self.stdout = io.TextIOWrapper(self.stdout,\n                 \
    \           encoding=encoding, errors=errors)\n            if errread != -1:\n\
    \                self.stderr = io.open(errread, 'rb', bufsize)\n             \
    \   if self.text_mode:\n                    self.stderr = io.TextIOWrapper(self.stderr,\n\
    \                            encoding=encoding, errors=errors)\n    \n>      \
    \     self._execute_child(args, executable, preexec_fn, close_fds,\n         \
    \                       pass_fds, cwd, env,\n                                startupinfo,\
    \ creationflags, shell,\n                                p2cread, p2cwrite,\n\
    \                                c2pread, c2pwrite,\n                        \
    \        errread, errwrite,\n                                restore_signals,\
    \ start_new_session)\n\n/usr/lib/python3.8/subprocess.py:854: \n_ _ _ _ _ _ _\
    \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
    \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <subprocess.Popen object at 0x7facec3bac40>,\
    \ args = ['/tmp/tmp884gpyrt.sh']\nexecutable = b'/tmp/tmp884gpyrt.sh', preexec_fn\
    \ = None, close_fds = True, pass_fds = ()\ncwd = '/usr/baki/python_projects/cookiecutter/inputshellhooks',\
    \ env = None, startupinfo = None, creationflags = 0\nshell = False, p2cread =\
    \ -1, p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1\n\
    restore_signals = True, start_new_session = False\n\n    def _execute_child(self,\
    \ args, executable, preexec_fn, close_fds,\n                       pass_fds, cwd,\
    \ env,\n                       startupinfo, creationflags, shell,\n          \
    \             p2cread, p2cwrite,\n                       c2pread, c2pwrite,\n\
    \                       errread, errwrite,\n                       restore_signals,\
    \ start_new_session):\n        \"\"\"Execute program (POSIX version)\"\"\"\n \
    \   \n        if isinstance(args, (str, bytes)):\n            args = [args]\n\
    \        elif isinstance(args, os.PathLike):\n            if shell:\n        \
    \        raise TypeError('path-like args is not allowed when '\n             \
    \                   'shell is true')\n            args = [args]\n        else:\n\
    \            args = list(args)\n    \n        if shell:\n            # On Android\
    \ the default shell is at '/system/bin/sh'.\n            unix_shell = ('/system/bin/sh'\
    \ if\n                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')\n\
    \            args = [unix_shell, \"-c\"] + args\n            if executable:\n\
    \                args[0] = executable\n    \n        if executable is None:\n\
    \            executable = args[0]\n    \n        sys.audit(\"subprocess.Popen\"\
    , executable, args, cwd, env)\n    \n        if (_USE_POSIX_SPAWN\n          \
    \      and os.path.dirname(executable)\n                and preexec_fn is None\n\
    \                and not close_fds\n                and not pass_fds\n       \
    \         and cwd is None\n                and (p2cread == -1 or p2cread > 2)\n\
    \                and (c2pwrite == -1 or c2pwrite > 2)\n                and (errwrite\
    \ == -1 or errwrite > 2)\n                and not start_new_session):\n      \
    \      self._posix_spawn(args, executable, env, restore_signals,\n           \
    \                   p2cread, p2cwrite,\n                              c2pread,\
    \ c2pwrite,\n                              errread, errwrite)\n            return\n\
    \    \n        orig_executable = executable\n    \n        # For transferring\
    \ possible exec failure from child to parent.\n        # Data format: \"exception\
    \ name:hex errno:description\"\n        # Pickle is not used; it is complex and\
    \ involves memory allocation.\n        errpipe_read, errpipe_write = os.pipe()\n\
    \        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.\n\
    \        low_fds_to_close = []\n        while errpipe_write < 3:\n           \
    \ low_fds_to_close.append(errpipe_write)\n            errpipe_write = os.dup(errpipe_write)\n\
    \        for low_fd in low_fds_to_close:\n            os.close(low_fd)\n     \
    \   try:\n            try:\n                # We must avoid complex work that\
    \ could involve\n                # malloc or free in the child process to avoid\n\
    \                # potential deadlocks, thus we do all this here.\n          \
    \      # and pass it to fork_exec()\n    \n                if env is not None:\n\
    \                    env_list = []\n                    for k, v in env.items():\n\
    \                        k = os.fsencode(k)\n                        if b'=' in\
    \ k:\n                            raise ValueError(\"illegal environment variable\
    \ name\")\n                        env_list.append(k + b'=' + os.fsencode(v))\n\
    \                else:\n                    env_list = None  # Use execv instead\
    \ of execve.\n                executable = os.fsencode(executable)\n         \
    \       if os.path.dirname(executable):\n                    executable_list =\
    \ (executable,)\n                else:\n                    # This matches the\
    \ behavior of os._execvpe().\n                    executable_list = tuple(\n \
    \                       os.path.join(os.fsencode(dir), executable)\n         \
    \               for dir in os.get_exec_path(env))\n                fds_to_keep\
    \ = set(pass_fds)\n                fds_to_keep.add(errpipe_write)\n          \
    \      self.pid = _posixsubprocess.fork_exec(\n                        args, executable_list,\n\
    \                        close_fds, tuple(sorted(map(int, fds_to_keep))),\n  \
    \                      cwd, env_list,\n                        p2cread, p2cwrite,\
    \ c2pread, c2pwrite,\n                        errread, errwrite,\n           \
    \             errpipe_read, errpipe_write,\n                        restore_signals,\
    \ start_new_session, preexec_fn)\n                self._child_created = True\n\
    \            finally:\n                # be sure the FD is closed no matter what\n\
    \                os.close(errpipe_write)\n    \n            self._close_pipe_fds(p2cread,\
    \ p2cwrite,\n                                 c2pread, c2pwrite,\n           \
    \                      errread, errwrite)\n    \n            # Wait for exec to\
    \ fail or succeed; possibly raising an\n            # exception (limited in size)\n\
    \            errpipe_data = bytearray()\n            while True:\n           \
    \     part = os.read(errpipe_read, 50000)\n                errpipe_data += part\n\
    \                if not part or len(errpipe_data) > 50000:\n                 \
    \   break\n        finally:\n            # be sure the FD is closed no matter\
    \ what\n            os.close(errpipe_read)\n    \n        if errpipe_data:\n \
    \           try:\n                pid, sts = os.waitpid(self.pid, 0)\n       \
    \         if pid == self.pid:\n                    self._handle_exitstatus(sts)\n\
    \                else:\n                    self.returncode = sys.maxsize\n  \
    \          except ChildProcessError:\n                pass\n    \n           \
    \ try:\n                exception_name, hex_errno, err_msg = (\n             \
    \           errpipe_data.split(b':', 2))\n                # The encoding here\
    \ should match the encoding\n                # written in by the subprocess implementations\n\
    \                # like _posixsubprocess\n                err_msg = err_msg.decode()\n\
    \            except ValueError:\n                exception_name = b'SubprocessError'\n\
    \                hex_errno = b'0'\n                err_msg = 'Bad exception data\
    \ from child: {!r}'.format(\n                              bytes(errpipe_data))\n\
    \            child_exception_type = getattr(\n                    builtins, exception_name.decode('ascii'),\n\
    \                    SubprocessError)\n            if issubclass(child_exception_type,\
    \ OSError) and hex_errno:\n                errno_num = int(hex_errno, 16)\n  \
    \              child_exec_never_called = (err_msg == \"noexec\")\n           \
    \     if child_exec_never_called:\n                    err_msg = \"\"\n      \
    \              # The error must be from chdir(cwd).\n                    err_filename\
    \ = cwd\n                else:\n                    err_filename = orig_executable\n\
    \                if errno_num != 0:\n                    err_msg = os.strerror(errno_num)\n\
    >               raise child_exception_type(errno_num, err_msg, err_filename)\n\
    E               OSError: [Errno 8] Exec format error: '/tmp/tmp884gpyrt.sh'\n\n\
    /usr/lib/python3.8/subprocess.py:1702: OSError\n\nDuring handling of the above\
    \ exception, another exception occurred:\n\n    @pytest.mark.skipif(WINDOWS, reason='OSError.errno=8\
    \ is not thrown on Windows')\n    @pytest.mark.usefixtures('clean_system', 'remove_additional_folders')\n\
    \    def test_empty_hooks():\n        \"\"\"Verify error is raised on empty hook\
    \ script. Ignored on windows.\n    \n        OSError.errno=8 is not thrown on\
    \ Windows when the script is empty\n        because it always runs through shell\
    \ instead of needing a shebang.\n        \"\"\"\n        with pytest.raises(FailedHookException)\
    \ as excinfo:\n>           generate.generate_files(\n                context={'cookiecutter':\
    \ {'shellhooks': 'shellhooks'}},\n                repo_dir='tests/test-shellhooks-empty/',\n\
    \                overwrite_if_exists=True,\n            )\n\ntests/test_generate_hooks.py:80:\
    \ \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
    \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/generate.py:304:\
    \ in generate_files\n    _run_hook_from_repo_dir(\ncookiecutter/generate.py:243:\
    \ in _run_hook_from_repo_dir\n    run_hook(hook_name, project_dir, context)\n\
    cookiecutter/hooks.py:131: in run_hook\n    run_script_with_context(script, project_dir,\
    \ context)\ncookiecutter/hooks.py:114: in run_script_with_context\n    run_script(temp.name,\
    \ cwd)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
    \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nscript_path = '/tmp/tmp884gpyrt.sh',\
    \ cwd = '/usr/baki/python_projects/cookiecutter/inputshellhooks'\n\n    def run_script(script_path,\
    \ cwd='.'):\n        \"\"\"Execute a script from a working directory.\n    \n\
    \        :param script_path: Absolute path to the script to run.\n        :param\
    \ cwd: The directory to run the script from.\n        \"\"\"\n        run_thru_shell\
    \ = sys.platform.startswith('win')\n        if script_path.endswith('.py'):\n\
    \            script_command = [sys.executable, script_path]\n        else:\n \
    \           script_command = [script_path]\n    \n        utils.make_executable(script_path)\n\
    \    \n        try:\n            proc = subprocess.Popen(script_command, shell=run_thru_shell,\
    \ cwd=cwd)\n            exit_status = proc.wait()\n            if exit_status\
    \ != EXIT_SUCCESS:\n                raise FailedHookException(\n             \
    \       'Hook script failed (exit status: {})'.format(exit_status)\n         \
    \       )\n        except OSError as os_error:\n            if os_error.errno\
    \ == errno.ENOEXEC:\n>               raise FailedHookException(\n            \
    \        'Hook script failed, might be an empty file or missing a shebang'\n \
    \               )\nE               cookiecutter.exceptions.FailedHookException:\
    \ Hook script failed, might be an empty file or missing a shebang\n\ncookiecutter/hooks.py:90:\
    \ FailedHookException"
  killer: tests/test_generate_hooks.py::test_empty_hooks
  module: *id001
  mutations:
  - lineno: 26
    operator: IOP
  number: 3
  status: killed
  tests_run: 4
  time: 1.758721113204956
- exception_traceback: "script_path = '/tmp/tmp83zu9x1j.sh', cwd = '/usr/baki/python_projects/cookiecutter/inputshellhooks'\n\
    \n    def run_script(script_path, cwd='.'):\n        \"\"\"Execute a script from\
    \ a working directory.\n    \n        :param script_path: Absolute path to the\
    \ script to run.\n        :param cwd: The directory to run the script from.\n\
    \        \"\"\"\n        run_thru_shell = sys.platform.startswith('win')\n   \
    \     if script_path.endswith('.py'):\n            script_command = [sys.executable,\
    \ script_path]\n        else:\n            script_command = [script_path]\n  \
    \  \n        utils.make_executable(script_path)\n    \n        try:\n>       \
    \    proc = subprocess.Popen(script_command, shell=run_thru_shell, cwd=cwd)\n\n\
    cookiecutter/hooks.py:82: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
    \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself\
    \ = <subprocess.Popen object at 0x7faceec183a0>, args = ['/tmp/tmp83zu9x1j.sh'],\
    \ bufsize = -1, executable = None\nstdin = None, stdout = None, stderr = None,\
    \ preexec_fn = None, close_fds = True, shell = False\ncwd = '/usr/baki/python_projects/cookiecutter/inputshellhooks',\
    \ env = None, universal_newlines = None\nstartupinfo = None, creationflags = 0,\
    \ restore_signals = True, start_new_session = False, pass_fds = ()\n\n    def\
    \ __init__(self, args, bufsize=-1, executable=None,\n                 stdin=None,\
    \ stdout=None, stderr=None,\n                 preexec_fn=None, close_fds=True,\n\
    \                 shell=False, cwd=None, env=None, universal_newlines=None,\n\
    \                 startupinfo=None, creationflags=0,\n                 restore_signals=True,\
    \ start_new_session=False,\n                 pass_fds=(), *, encoding=None, errors=None,\
    \ text=None):\n        \"\"\"Create new Popen instance.\"\"\"\n        _cleanup()\n\
    \        # Held while anything is calling waitpid before returncode has been\n\
    \        # updated to prevent clobbering returncode if wait() or poll() are\n\
    \        # called from multiple threads at once.  After acquiring the lock,\n\
    \        # code must re-check self.returncode to see if another thread just\n\
    \        # finished a waitpid() call.\n        self._waitpid_lock = threading.Lock()\n\
    \    \n        self._input = None\n        self._communication_started = False\n\
    \        if bufsize is None:\n            bufsize = -1  # Restore default\n  \
    \      if not isinstance(bufsize, int):\n            raise TypeError(\"bufsize\
    \ must be an integer\")\n    \n        if _mswindows:\n            if preexec_fn\
    \ is not None:\n                raise ValueError(\"preexec_fn is not supported\
    \ on Windows \"\n                                 \"platforms\")\n        else:\n\
    \            # POSIX\n            if pass_fds and not close_fds:\n           \
    \     warnings.warn(\"pass_fds overriding close_fds.\", RuntimeWarning)\n    \
    \            close_fds = True\n            if startupinfo is not None:\n     \
    \           raise ValueError(\"startupinfo is only supported on Windows \"\n \
    \                                \"platforms\")\n            if creationflags\
    \ != 0:\n                raise ValueError(\"creationflags is only supported on\
    \ Windows \"\n                                 \"platforms\")\n    \n        self.args\
    \ = args\n        self.stdin = None\n        self.stdout = None\n        self.stderr\
    \ = None\n        self.pid = None\n        self.returncode = None\n        self.encoding\
    \ = encoding\n        self.errors = errors\n    \n        # Validate the combinations\
    \ of text and universal_newlines\n        if (text is not None and universal_newlines\
    \ is not None\n            and bool(universal_newlines) != bool(text)):\n    \
    \        raise SubprocessError('Cannot disambiguate when both text '\n       \
    \                           'and universal_newlines are supplied but '\n     \
    \                             'different. Pass one or the other.')\n    \n   \
    \     # Input and output objects. The general principle is like\n        # this:\n\
    \        #\n        # Parent                   Child\n        # ------       \
    \            -----\n        # p2cwrite   ---stdin--->  p2cread\n        # c2pread\
    \    <--stdout---  c2pwrite\n        # errread    <--stderr---  errwrite\n   \
    \     #\n        # On POSIX, the child objects are file descriptors.  On\n   \
    \     # Windows, these are Windows file handles.  The parent objects\n       \
    \ # are file descriptors on both platforms.  The parent objects\n        # are\
    \ -1 when not using PIPEs. The child objects are -1\n        # when not redirecting.\n\
    \    \n        (p2cread, p2cwrite,\n         c2pread, c2pwrite,\n         errread,\
    \ errwrite) = self._get_handles(stdin, stdout, stderr)\n    \n        # We wrap\
    \ OS handles *before* launching the child, otherwise a\n        # quickly terminating\
    \ child could make our fds unwrappable\n        # (see #8458).\n    \n       \
    \ if _mswindows:\n            if p2cwrite != -1:\n                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(),\
    \ 0)\n            if c2pread != -1:\n                c2pread = msvcrt.open_osfhandle(c2pread.Detach(),\
    \ 0)\n            if errread != -1:\n                errread = msvcrt.open_osfhandle(errread.Detach(),\
    \ 0)\n    \n        self.text_mode = encoding or errors or text or universal_newlines\n\
    \    \n        # How long to resume waiting on a child after the first ^C.\n \
    \       # There is no right value for this.  The purpose is to be polite\n   \
    \     # yet remain good for interactive users trying to exit a tool.\n       \
    \ self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()\n    \n       \
    \ self._closed_child_pipe_fds = False\n    \n        if self.text_mode:\n    \
    \        if bufsize == 1:\n                line_buffering = True\n           \
    \     # Use the default buffer size for the underlying binary streams\n      \
    \          # since they don't support line buffering.\n                bufsize\
    \ = -1\n            else:\n                line_buffering = False\n    \n    \
    \    try:\n            if p2cwrite != -1:\n                self.stdin = io.open(p2cwrite,\
    \ 'wb', bufsize)\n                if self.text_mode:\n                    self.stdin\
    \ = io.TextIOWrapper(self.stdin, write_through=True,\n                       \
    \     line_buffering=line_buffering,\n                            encoding=encoding,\
    \ errors=errors)\n            if c2pread != -1:\n                self.stdout =\
    \ io.open(c2pread, 'rb', bufsize)\n                if self.text_mode:\n      \
    \              self.stdout = io.TextIOWrapper(self.stdout,\n                 \
    \           encoding=encoding, errors=errors)\n            if errread != -1:\n\
    \                self.stderr = io.open(errread, 'rb', bufsize)\n             \
    \   if self.text_mode:\n                    self.stderr = io.TextIOWrapper(self.stderr,\n\
    \                            encoding=encoding, errors=errors)\n    \n>      \
    \     self._execute_child(args, executable, preexec_fn, close_fds,\n         \
    \                       pass_fds, cwd, env,\n                                startupinfo,\
    \ creationflags, shell,\n                                p2cread, p2cwrite,\n\
    \                                c2pread, c2pwrite,\n                        \
    \        errread, errwrite,\n                                restore_signals,\
    \ start_new_session)\n\n/usr/lib/python3.8/subprocess.py:854: \n_ _ _ _ _ _ _\
    \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
    \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <subprocess.Popen object at 0x7faceec183a0>,\
    \ args = ['/tmp/tmp83zu9x1j.sh']\nexecutable = b'/tmp/tmp83zu9x1j.sh', preexec_fn\
    \ = None, close_fds = True, pass_fds = ()\ncwd = '/usr/baki/python_projects/cookiecutter/inputshellhooks',\
    \ env = None, startupinfo = None, creationflags = 0\nshell = False, p2cread =\
    \ -1, p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1\n\
    restore_signals = True, start_new_session = False\n\n    def _execute_child(self,\
    \ args, executable, preexec_fn, close_fds,\n                       pass_fds, cwd,\
    \ env,\n                       startupinfo, creationflags, shell,\n          \
    \             p2cread, p2cwrite,\n                       c2pread, c2pwrite,\n\
    \                       errread, errwrite,\n                       restore_signals,\
    \ start_new_session):\n        \"\"\"Execute program (POSIX version)\"\"\"\n \
    \   \n        if isinstance(args, (str, bytes)):\n            args = [args]\n\
    \        elif isinstance(args, os.PathLike):\n            if shell:\n        \
    \        raise TypeError('path-like args is not allowed when '\n             \
    \                   'shell is true')\n            args = [args]\n        else:\n\
    \            args = list(args)\n    \n        if shell:\n            # On Android\
    \ the default shell is at '/system/bin/sh'.\n            unix_shell = ('/system/bin/sh'\
    \ if\n                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')\n\
    \            args = [unix_shell, \"-c\"] + args\n            if executable:\n\
    \                args[0] = executable\n    \n        if executable is None:\n\
    \            executable = args[0]\n    \n        sys.audit(\"subprocess.Popen\"\
    , executable, args, cwd, env)\n    \n        if (_USE_POSIX_SPAWN\n          \
    \      and os.path.dirname(executable)\n                and preexec_fn is None\n\
    \                and not close_fds\n                and not pass_fds\n       \
    \         and cwd is None\n                and (p2cread == -1 or p2cread > 2)\n\
    \                and (c2pwrite == -1 or c2pwrite > 2)\n                and (errwrite\
    \ == -1 or errwrite > 2)\n                and not start_new_session):\n      \
    \      self._posix_spawn(args, executable, env, restore_signals,\n           \
    \                   p2cread, p2cwrite,\n                              c2pread,\
    \ c2pwrite,\n                              errread, errwrite)\n            return\n\
    \    \n        orig_executable = executable\n    \n        # For transferring\
    \ possible exec failure from child to parent.\n        # Data format: \"exception\
    \ name:hex errno:description\"\n        # Pickle is not used; it is complex and\
    \ involves memory allocation.\n        errpipe_read, errpipe_write = os.pipe()\n\
    \        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.\n\
    \        low_fds_to_close = []\n        while errpipe_write < 3:\n           \
    \ low_fds_to_close.append(errpipe_write)\n            errpipe_write = os.dup(errpipe_write)\n\
    \        for low_fd in low_fds_to_close:\n            os.close(low_fd)\n     \
    \   try:\n            try:\n                # We must avoid complex work that\
    \ could involve\n                # malloc or free in the child process to avoid\n\
    \                # potential deadlocks, thus we do all this here.\n          \
    \      # and pass it to fork_exec()\n    \n                if env is not None:\n\
    \                    env_list = []\n                    for k, v in env.items():\n\
    \                        k = os.fsencode(k)\n                        if b'=' in\
    \ k:\n                            raise ValueError(\"illegal environment variable\
    \ name\")\n                        env_list.append(k + b'=' + os.fsencode(v))\n\
    \                else:\n                    env_list = None  # Use execv instead\
    \ of execve.\n                executable = os.fsencode(executable)\n         \
    \       if os.path.dirname(executable):\n                    executable_list =\
    \ (executable,)\n                else:\n                    # This matches the\
    \ behavior of os._execvpe().\n                    executable_list = tuple(\n \
    \                       os.path.join(os.fsencode(dir), executable)\n         \
    \               for dir in os.get_exec_path(env))\n                fds_to_keep\
    \ = set(pass_fds)\n                fds_to_keep.add(errpipe_write)\n          \
    \      self.pid = _posixsubprocess.fork_exec(\n                        args, executable_list,\n\
    \                        close_fds, tuple(sorted(map(int, fds_to_keep))),\n  \
    \                      cwd, env_list,\n                        p2cread, p2cwrite,\
    \ c2pread, c2pwrite,\n                        errread, errwrite,\n           \
    \             errpipe_read, errpipe_write,\n                        restore_signals,\
    \ start_new_session, preexec_fn)\n                self._child_created = True\n\
    \            finally:\n                # be sure the FD is closed no matter what\n\
    \                os.close(errpipe_write)\n    \n            self._close_pipe_fds(p2cread,\
    \ p2cwrite,\n                                 c2pread, c2pwrite,\n           \
    \                      errread, errwrite)\n    \n            # Wait for exec to\
    \ fail or succeed; possibly raising an\n            # exception (limited in size)\n\
    \            errpipe_data = bytearray()\n            while True:\n           \
    \     part = os.read(errpipe_read, 50000)\n                errpipe_data += part\n\
    \                if not part or len(errpipe_data) > 50000:\n                 \
    \   break\n        finally:\n            # be sure the FD is closed no matter\
    \ what\n            os.close(errpipe_read)\n    \n        if errpipe_data:\n \
    \           try:\n                pid, sts = os.waitpid(self.pid, 0)\n       \
    \         if pid == self.pid:\n                    self._handle_exitstatus(sts)\n\
    \                else:\n                    self.returncode = sys.maxsize\n  \
    \          except ChildProcessError:\n                pass\n    \n           \
    \ try:\n                exception_name, hex_errno, err_msg = (\n             \
    \           errpipe_data.split(b':', 2))\n                # The encoding here\
    \ should match the encoding\n                # written in by the subprocess implementations\n\
    \                # like _posixsubprocess\n                err_msg = err_msg.decode()\n\
    \            except ValueError:\n                exception_name = b'SubprocessError'\n\
    \                hex_errno = b'0'\n                err_msg = 'Bad exception data\
    \ from child: {!r}'.format(\n                              bytes(errpipe_data))\n\
    \            child_exception_type = getattr(\n                    builtins, exception_name.decode('ascii'),\n\
    \                    SubprocessError)\n            if issubclass(child_exception_type,\
    \ OSError) and hex_errno:\n                errno_num = int(hex_errno, 16)\n  \
    \              child_exec_never_called = (err_msg == \"noexec\")\n           \
    \     if child_exec_never_called:\n                    err_msg = \"\"\n      \
    \              # The error must be from chdir(cwd).\n                    err_filename\
    \ = cwd\n                else:\n                    err_filename = orig_executable\n\
    \                if errno_num != 0:\n                    err_msg = os.strerror(errno_num)\n\
    >               raise child_exception_type(errno_num, err_msg, err_filename)\n\
    E               OSError: [Errno 8] Exec format error: '/tmp/tmp83zu9x1j.sh'\n\n\
    /usr/lib/python3.8/subprocess.py:1702: OSError\n\nDuring handling of the above\
    \ exception, another exception occurred:\n\n    @pytest.mark.skipif(WINDOWS, reason='OSError.errno=8\
    \ is not thrown on Windows')\n    @pytest.mark.usefixtures('clean_system', 'remove_additional_folders')\n\
    \    def test_empty_hooks():\n        \"\"\"Verify error is raised on empty hook\
    \ script. Ignored on windows.\n    \n        OSError.errno=8 is not thrown on\
    \ Windows when the script is empty\n        because it always runs through shell\
    \ instead of needing a shebang.\n        \"\"\"\n        with pytest.raises(FailedHookException)\
    \ as excinfo:\n>           generate.generate_files(\n                context={'cookiecutter':\
    \ {'shellhooks': 'shellhooks'}},\n                repo_dir='tests/test-shellhooks-empty/',\n\
    \                overwrite_if_exists=True,\n            )\n\ntests/test_generate_hooks.py:80:\
    \ \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
    \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/generate.py:304:\
    \ in generate_files\n    _run_hook_from_repo_dir(\ncookiecutter/generate.py:243:\
    \ in _run_hook_from_repo_dir\n    run_hook(hook_name, project_dir, context)\n\
    cookiecutter/hooks.py:131: in run_hook\n    run_script_with_context(script, project_dir,\
    \ context)\ncookiecutter/hooks.py:114: in run_script_with_context\n    run_script(temp.name,\
    \ cwd)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
    \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nscript_path = '/tmp/tmp83zu9x1j.sh',\
    \ cwd = '/usr/baki/python_projects/cookiecutter/inputshellhooks'\n\n    def run_script(script_path,\
    \ cwd='.'):\n        \"\"\"Execute a script from a working directory.\n    \n\
    \        :param script_path: Absolute path to the script to run.\n        :param\
    \ cwd: The directory to run the script from.\n        \"\"\"\n        run_thru_shell\
    \ = sys.platform.startswith('win')\n        if script_path.endswith('.py'):\n\
    \            script_command = [sys.executable, script_path]\n        else:\n \
    \           script_command = [script_path]\n    \n        utils.make_executable(script_path)\n\
    \    \n        try:\n            proc = subprocess.Popen(script_command, shell=run_thru_shell,\
    \ cwd=cwd)\n            exit_status = proc.wait()\n            if exit_status\
    \ != EXIT_SUCCESS:\n                raise FailedHookException(\n             \
    \       'Hook script failed (exit status: {})'.format(exit_status)\n         \
    \       )\n        except OSError as os_error:\n            if os_error.errno\
    \ == errno.ENOEXEC:\n>               raise FailedHookException(\n            \
    \        'Hook script failed, might be an empty file or missing a shebang'\n \
    \               )\nE               cookiecutter.exceptions.FailedHookException:\
    \ Hook script failed, might be an empty file or missing a shebang\n\ncookiecutter/hooks.py:90:\
    \ FailedHookException"
  killer: tests/test_generate_hooks.py::test_empty_hooks
  module: *id001
  mutations:
  - lineno: 43
    operator: IOP
  number: 4
  status: killed
  tests_run: 4
  time: 1.6628952026367188
number_of_tests: 204
targets:
- cookiecutter/
tests:
- name: tests.conftest
  target: null
  time: 1.1739020347595215
- name: tests.test_abort_generate_on_hook_error
  target: null
  time: 1.020148515701294
- name: tests.test_cli
  target: null
  time: 0.7835743427276611
- name: tests.test_cookiecutter_invocation
  target: null
  time: 0.939061164855957
- name: tests.test_cookiecutter_local_no_input
  target: null
  time: 0.5449154376983643
- name: tests.test_cookiecutter_local_with_input
  target: null
  time: 0.4357600212097168
- name: tests.test_custom_extensions_in_hooks
  target: null
  time: 1.0339102745056152
- name: tests.test_default_extensions
  target: null
  time: 0.5813512802124023
- name: tests.test_environment
  target: null
  time: 0.35088419914245605
- name: tests.test_exceptions
  target: null
  time: 0.35394716262817383
- name: tests.test_find
  target: null
  time: 0.34936952590942383
- name: tests.test_generate_context
  target: null
  time: 0.38887810707092285
- name: tests.test_generate_copy_without_render
  target: null
  time: 0.3754403591156006
- name: tests.test_generate_file
  target: null
  time: 0.4161555767059326
- name: tests.test_generate_files
  target: null
  time: 0.8831348419189453
- name: tests.test_generate_hooks
  target: null
  time: 1.541078805923462
- name: tests.test_get_config
  target: null
  time: 0.3634817600250244
- name: tests.test_get_user_config
  target: null
  time: 0.38948607444763184
- name: tests.test_hooks
  target: null
  time: 0.720710277557373
- name: tests.test_log
  target: null
  time: 0.36339855194091797
- name: tests.test_main
  target: null
  time: 0.4559483528137207
- name: tests.test_output_folder
  target: null
  time: 0.3838813304901123
- name: tests.test_preferred_encoding
  target: null
  time: 0.34952759742736816
- name: tests.test_prompt
  target: null
  time: 0.5532491207122803
- name: tests.test_read_repo_password
  target: null
  time: 0.3547523021697998
- name: tests.test_read_user_choice
  target: null
  time: 0.39121389389038086
- name: tests.test_read_user_dict
  target: null
  time: 0.37456417083740234
- name: tests.test_read_user_variable
  target: null
  time: 0.4259936809539795
- name: tests.test_read_user_yes_no
  target: null
  time: 0.3494722843170166
- name: tests.test_repo_not_found
  target: null
  time: 0.35257601737976074
- name: tests.test_specify_output_dir
  target: null
  time: 0.39817070960998535
- name: tests.test_utils
  target: null
  time: 0.41774797439575195
time_stats:
  create_mutant_module: 0.0023012161254882812
  create_target_ast: 0.06034564971923828
  mutate_module: 140.511705160141
  run_tests_with_mutant: 9.565295696258545
total_time: 158.52812552452087
