<!DOCTYPE html>
<html>
<head>
    <title>MutPy mutation report - mutation #3</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css">
    
<link href="http://alexgorbatchev.com/pub/sh/current/styles/shCore.css" rel="stylesheet" type="text/css" />
<link href="http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css" rel="stylesheet" type="text/css" />

    <script src="https://code.jquery.com/jquery.js"></script>
    <script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script>
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
    
<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js" type="text/javascript"></script>
<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shBrushPython.js" type="text/javascript"></script>
<script type="text/javascript">
    SyntaxHighlighter.all();
    window.setTimeout(function () {
        
        $('.line.number26').attr('title', 'IOP');
        
    }, 0);
</script>

</head>
<body>
    <div class="container">
        
<div class="page-header">
    <h1>Mutation #3</h1>
</div>
<h3>Details</h3>
<ul>
    <li>module - <code><module 'cookiecutter.extensions' from '/usr/baki/python_projects/cookiecutter/cookiecutter/extensions.py'></code></li>
    <li><span class="label label-success">killed</span> by <code>tests/test_generate_hooks.py::test_empty_hooks</code></li>
    
    <li>duration - 1.759 s</li>
    
    
    <li>tests run - 4</li>
    
</ul>

<h3>Exception traceback</h3>
<pre>script_path = '/tmp/tmp884gpyrt.sh', cwd = '/usr/baki/python_projects/cookiecutter/inputshellhooks'

    def run_script(script_path, cwd='.'):
        """Execute a script from a working directory.
    
        :param script_path: Absolute path to the script to run.
        :param cwd: The directory to run the script from.
        """
        run_thru_shell = sys.platform.startswith('win')
        if script_path.endswith('.py'):
            script_command = [sys.executable, script_path]
        else:
            script_command = [script_path]
    
        utils.make_executable(script_path)
    
        try:
>           proc = subprocess.Popen(script_command, shell=run_thru_shell, cwd=cwd)

cookiecutter/hooks.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <subprocess.Popen object at 0x7facec3bac40>, args = ['/tmp/tmp884gpyrt.sh'], bufsize = -1, executable = None
stdin = None, stdout = None, stderr = None, preexec_fn = None, close_fds = True, shell = False
cwd = '/usr/baki/python_projects/cookiecutter/inputshellhooks', env = None, universal_newlines = None
startupinfo = None, creationflags = 0, restore_signals = True, start_new_session = False, pass_fds = ()

    def __init__(self, args, bufsize=-1, executable=None,
                 stdin=None, stdout=None, stderr=None,
                 preexec_fn=None, close_fds=True,
                 shell=False, cwd=None, env=None, universal_newlines=None,
                 startupinfo=None, creationflags=0,
                 restore_signals=True, start_new_session=False,
                 pass_fds=(), *, encoding=None, errors=None, text=None):
        """Create new Popen instance."""
        _cleanup()
        # Held while anything is calling waitpid before returncode has been
        # updated to prevent clobbering returncode if wait() or poll() are
        # called from multiple threads at once.  After acquiring the lock,
        # code must re-check self.returncode to see if another thread just
        # finished a waitpid() call.
        self._waitpid_lock = threading.Lock()
    
        self._input = None
        self._communication_started = False
        if bufsize is None:
            bufsize = -1  # Restore default
        if not isinstance(bufsize, int):
            raise TypeError("bufsize must be an integer")
    
        if _mswindows:
            if preexec_fn is not None:
                raise ValueError("preexec_fn is not supported on Windows "
                                 "platforms")
        else:
            # POSIX
            if pass_fds and not close_fds:
                warnings.warn("pass_fds overriding close_fds.", RuntimeWarning)
                close_fds = True
            if startupinfo is not None:
                raise ValueError("startupinfo is only supported on Windows "
                                 "platforms")
            if creationflags != 0:
                raise ValueError("creationflags is only supported on Windows "
                                 "platforms")
    
        self.args = args
        self.stdin = None
        self.stdout = None
        self.stderr = None
        self.pid = None
        self.returncode = None
        self.encoding = encoding
        self.errors = errors
    
        # Validate the combinations of text and universal_newlines
        if (text is not None and universal_newlines is not None
            and bool(universal_newlines) != bool(text)):
            raise SubprocessError('Cannot disambiguate when both text '
                                  'and universal_newlines are supplied but '
                                  'different. Pass one or the other.')
    
        # Input and output objects. The general principle is like
        # this:
        #
        # Parent                   Child
        # ------                   -----
        # p2cwrite   ---stdin--->  p2cread
        # c2pread    <--stdout---  c2pwrite
        # errread    <--stderr---  errwrite
        #
        # On POSIX, the child objects are file descriptors.  On
        # Windows, these are Windows file handles.  The parent objects
        # are file descriptors on both platforms.  The parent objects
        # are -1 when not using PIPEs. The child objects are -1
        # when not redirecting.
    
        (p2cread, p2cwrite,
         c2pread, c2pwrite,
         errread, errwrite) = self._get_handles(stdin, stdout, stderr)
    
        # We wrap OS handles *before* launching the child, otherwise a
        # quickly terminating child could make our fds unwrappable
        # (see #8458).
    
        if _mswindows:
            if p2cwrite != -1:
                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)
            if c2pread != -1:
                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)
            if errread != -1:
                errread = msvcrt.open_osfhandle(errread.Detach(), 0)
    
        self.text_mode = encoding or errors or text or universal_newlines
    
        # How long to resume waiting on a child after the first ^C.
        # There is no right value for this.  The purpose is to be polite
        # yet remain good for interactive users trying to exit a tool.
        self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()
    
        self._closed_child_pipe_fds = False
    
        if self.text_mode:
            if bufsize == 1:
                line_buffering = True
                # Use the default buffer size for the underlying binary streams
                # since they don't support line buffering.
                bufsize = -1
            else:
                line_buffering = False
    
        try:
            if p2cwrite != -1:
                self.stdin = io.open(p2cwrite, 'wb', bufsize)
                if self.text_mode:
                    self.stdin = io.TextIOWrapper(self.stdin, write_through=True,
                            line_buffering=line_buffering,
                            encoding=encoding, errors=errors)
            if c2pread != -1:
                self.stdout = io.open(c2pread, 'rb', bufsize)
                if self.text_mode:
                    self.stdout = io.TextIOWrapper(self.stdout,
                            encoding=encoding, errors=errors)
            if errread != -1:
                self.stderr = io.open(errread, 'rb', bufsize)
                if self.text_mode:
                    self.stderr = io.TextIOWrapper(self.stderr,
                            encoding=encoding, errors=errors)
    
>           self._execute_child(args, executable, preexec_fn, close_fds,
                                pass_fds, cwd, env,
                                startupinfo, creationflags, shell,
                                p2cread, p2cwrite,
                                c2pread, c2pwrite,
                                errread, errwrite,
                                restore_signals, start_new_session)

/usr/lib/python3.8/subprocess.py:854: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <subprocess.Popen object at 0x7facec3bac40>, args = ['/tmp/tmp884gpyrt.sh']
executable = b'/tmp/tmp884gpyrt.sh', preexec_fn = None, close_fds = True, pass_fds = ()
cwd = '/usr/baki/python_projects/cookiecutter/inputshellhooks', env = None, startupinfo = None, creationflags = 0
shell = False, p2cread = -1, p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals, start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session, preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               OSError: [Errno 8] Exec format error: '/tmp/tmp884gpyrt.sh'

/usr/lib/python3.8/subprocess.py:1702: OSError

During handling of the above exception, another exception occurred:

    @pytest.mark.skipif(WINDOWS, reason='OSError.errno=8 is not thrown on Windows')
    @pytest.mark.usefixtures('clean_system', 'remove_additional_folders')
    def test_empty_hooks():
        """Verify error is raised on empty hook script. Ignored on windows.
    
        OSError.errno=8 is not thrown on Windows when the script is empty
        because it always runs through shell instead of needing a shebang.
        """
        with pytest.raises(FailedHookException) as excinfo:
>           generate.generate_files(
                context={'cookiecutter': {'shellhooks': 'shellhooks'}},
                repo_dir='tests/test-shellhooks-empty/',
                overwrite_if_exists=True,
            )

tests/test_generate_hooks.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cookiecutter/generate.py:304: in generate_files
    _run_hook_from_repo_dir(
cookiecutter/generate.py:243: in _run_hook_from_repo_dir
    run_hook(hook_name, project_dir, context)
cookiecutter/hooks.py:131: in run_hook
    run_script_with_context(script, project_dir, context)
cookiecutter/hooks.py:114: in run_script_with_context
    run_script(temp.name, cwd)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

script_path = '/tmp/tmp884gpyrt.sh', cwd = '/usr/baki/python_projects/cookiecutter/inputshellhooks'

    def run_script(script_path, cwd='.'):
        """Execute a script from a working directory.
    
        :param script_path: Absolute path to the script to run.
        :param cwd: The directory to run the script from.
        """
        run_thru_shell = sys.platform.startswith('win')
        if script_path.endswith('.py'):
            script_command = [sys.executable, script_path]
        else:
            script_command = [script_path]
    
        utils.make_executable(script_path)
    
        try:
            proc = subprocess.Popen(script_command, shell=run_thru_shell, cwd=cwd)
            exit_status = proc.wait()
            if exit_status != EXIT_SUCCESS:
                raise FailedHookException(
                    'Hook script failed (exit status: {})'.format(exit_status)
                )
        except OSError as os_error:
            if os_error.errno == errno.ENOEXEC:
>               raise FailedHookException(
                    'Hook script failed, might be an empty file or missing a shebang'
                )
E               cookiecutter.exceptions.FailedHookException: Hook script failed, might be an empty file or missing a shebang

cookiecutter/hooks.py:90: FailedHookException</pre>

<h3>Mutations</h3>
<ul>
    
    <li>IOP - line 26</li>
    
</ul>
<h3>Mutant</h3>
<pre class="brush: python; first-line: 1; highlight: [26]; toolbar: false;">'''Jinja2 extensions.'''
import json
import string
from secrets import choice

from jinja2.ext import Extension
from slugify import slugify as pyslugify


class JsonifyExtension(Extension):
    '''Jinja2 extension to convert a Python object to JSON.'''
    
    def __init__(self, environment):
        '''Initialize the extension with the given environment.'''
        super(JsonifyExtension, self).__init__(environment)
        
        def jsonify(obj):
            return json.dumps(obj, sort_keys=True, indent=4)
        
        environment.filters['jsonify'] = jsonify


class RandomStringExtension(Extension):
    '''Jinja2 extension to create a random string.'''
    
    def __init__(self, environment):
        super(RandomStringExtension, self).__init__(environment)
        '''Jinja2 Extension Constructor.'''
        
        
        def random_ascii_string(length, punctuation=False):
            if punctuation:
                corpus = ''.join((string.ascii_letters, string.punctuation))
            else:
                corpus = string.ascii_letters
            return ''.join((choice(corpus) for _ in range(length)))
        
        environment.globals.update(random_ascii_string=random_ascii_string)

class SlugifyExtension(Extension):
    '''Jinja2 Extension to slugify string.'''
    
    def __init__(self, environment):
        '''Jinja2 Extension constructor.'''
        super(SlugifyExtension, self).__init__(environment)
        
        def slugify(value, **kwargs):
            '''Slugifies the value.'''
            return pyslugify(value, **kwargs)
        
        environment.filters['slugify'] = slugify</pre>

    </div>
</body>
</html>