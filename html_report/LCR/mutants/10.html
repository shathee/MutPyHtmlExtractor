<!DOCTYPE html>
<html>
<head>
    <title>MutPy mutation report - mutation #10</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css">
    
<link href="http://alexgorbatchev.com/pub/sh/current/styles/shCore.css" rel="stylesheet" type="text/css" />
<link href="http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css" rel="stylesheet" type="text/css" />

    <script src="https://code.jquery.com/jquery.js"></script>
    <script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script>
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
    
<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js" type="text/javascript"></script>
<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shBrushPython.js" type="text/javascript"></script>
<script type="text/javascript">
    SyntaxHighlighter.all();
    window.setTimeout(function () {
        
        $('.line.number55').attr('title', 'LCR');
        
    }, 0);
</script>

</head>
<body>
    <div class="container">
        
<div class="page-header">
    <h1>Mutation #10</h1>
</div>
<h3>Details</h3>
<ul>
    <li>module - <code><module 'cookiecutter.main' from '/usr/baki/python_projects/cookiecutter/cookiecutter/main.py'></code></li>
    <li><span class="label label-success">killed</span> by <code>tests/test_specify_output_dir.py::test_api_invocation</code></li>
    
    <li>duration - 0.783 s</li>
    
    
    <li>tests run - -89</li>
    
</ul>

<h3>Exception traceback</h3>
<pre>context_file = '/tmp/pytest-of-ubuntu/pytest-648/test_api_invocation0/template/cookiecutter.json'
default_context = OrderedDict(), extra_context = None

    def generate_context(
        context_file='cookiecutter.json', default_context=None, extra_context=None
    ):
        """Generate the context for a Cookiecutter project template.
    
        Loads the JSON file as a Python object, with key being the JSON filename.
    
        :param context_file: JSON file containing key/value pairs for populating
            the cookiecutter's variables.
        :param default_context: Dictionary containing config to take into account.
        :param extra_context: Dictionary containing configuration overrides
        """
        context = OrderedDict([])
    
        try:
            with open(context_file, encoding='utf-8') as file_handle:
>               obj = json.load(file_handle, object_pairs_hook=OrderedDict)

cookiecutter/generate.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fp = <_io.TextIOWrapper name='/tmp/pytest-of-ubuntu/pytest-648/test_api_invocation0/template/cookiecutter.json' mode='r' encoding='utf-8'>
cls = None, object_hook = None, parse_float = None, parse_int = None, parse_constant = None
object_pairs_hook = <class 'collections.OrderedDict'>, kw = {}

    def load(fp, *, cls=None, object_hook=None, parse_float=None,
            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):
        """Deserialize ``fp`` (a ``.read()``-supporting file-like object containing
        a JSON document) to a Python object.
    
        ``object_hook`` is an optional function that will be called with the
        result of any object literal decode (a ``dict``). The return value of
        ``object_hook`` will be used instead of the ``dict``. This feature
        can be used to implement custom decoders (e.g. JSON-RPC class hinting).
    
        ``object_pairs_hook`` is an optional function that will be called with the
        result of any object literal decoded with an ordered list of pairs.  The
        return value of ``object_pairs_hook`` will be used instead of the ``dict``.
        This feature can be used to implement custom decoders.  If ``object_hook``
        is also defined, the ``object_pairs_hook`` takes priority.
    
        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``
        kwarg; otherwise ``JSONDecoder`` is used.
        """
>       return loads(fp.read(),
            cls=cls, object_hook=object_hook,
            parse_float=parse_float, parse_int=parse_int,
            parse_constant=parse_constant, object_pairs_hook=object_pairs_hook, **kw)

/usr/lib/python3.8/json/__init__.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = '', cls = <class 'json.decoder.JSONDecoder'>, object_hook = None, parse_float = None, parse_int = None
parse_constant = None, object_pairs_hook = <class 'collections.OrderedDict'>
kw = {'object_pairs_hook': <class 'collections.OrderedDict'>}

    def loads(s, *, cls=None, object_hook=None, parse_float=None,
            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):
        """Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance
        containing a JSON document) to a Python object.
    
        ``object_hook`` is an optional function that will be called with the
        result of any object literal decode (a ``dict``). The return value of
        ``object_hook`` will be used instead of the ``dict``. This feature
        can be used to implement custom decoders (e.g. JSON-RPC class hinting).
    
        ``object_pairs_hook`` is an optional function that will be called with the
        result of any object literal decoded with an ordered list of pairs.  The
        return value of ``object_pairs_hook`` will be used instead of the ``dict``.
        This feature can be used to implement custom decoders.  If ``object_hook``
        is also defined, the ``object_pairs_hook`` takes priority.
    
        ``parse_float``, if specified, will be called with the string
        of every JSON float to be decoded. By default this is equivalent to
        float(num_str). This can be used to use another datatype or parser
        for JSON floats (e.g. decimal.Decimal).
    
        ``parse_int``, if specified, will be called with the string
        of every JSON int to be decoded. By default this is equivalent to
        int(num_str). This can be used to use another datatype or parser
        for JSON integers (e.g. float).
    
        ``parse_constant``, if specified, will be called with one of the
        following strings: -Infinity, Infinity, NaN.
        This can be used to raise an exception if invalid JSON numbers
        are encountered.
    
        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``
        kwarg; otherwise ``JSONDecoder`` is used.
    
        The ``encoding`` argument is ignored and deprecated since Python 3.1.
        """
        if isinstance(s, str):
            if s.startswith('\ufeff'):
                raise JSONDecodeError("Unexpected UTF-8 BOM (decode using utf-8-sig)",
                                      s, 0)
        else:
            if not isinstance(s, (bytes, bytearray)):
                raise TypeError(f'the JSON object must be str, bytes or bytearray, '
                                f'not {s.__class__.__name__}')
            s = s.decode(detect_encoding(s), 'surrogatepass')
    
        if "encoding" in kw:
            import warnings
            warnings.warn(
                "'encoding' is ignored and deprecated. It will be removed in Python 3.9",
                DeprecationWarning,
                stacklevel=2
            )
            del kw['encoding']
    
        if (cls is None and object_hook is None and
                parse_int is None and parse_float is None and
                parse_constant is None and object_pairs_hook is None and not kw):
            return _default_decoder.decode(s)
        if cls is None:
            cls = JSONDecoder
        if object_hook is not None:
            kw['object_hook'] = object_hook
        if object_pairs_hook is not None:
            kw['object_pairs_hook'] = object_pairs_hook
        if parse_float is not None:
            kw['parse_float'] = parse_float
        if parse_int is not None:
            kw['parse_int'] = parse_int
        if parse_constant is not None:
            kw['parse_constant'] = parse_constant
>       return cls(**kw).decode(s)

/usr/lib/python3.8/json/__init__.py:370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe39d1fd100>, s = ''
_w = <built-in method match of re.Pattern object at 0x7fe3a0863db0>

    def decode(self, s, _w=WHITESPACE.match):
        """Return the Python representation of ``s`` (a ``str`` instance
        containing a JSON document).
    
        """
>       obj, end = self.raw_decode(s, idx=_w(s, 0).end())

/usr/lib/python3.8/json/decoder.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe39d1fd100>, s = '', idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.8/json/decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

mocker = <pytest_mock.plugin.MockFixture object at 0x7fe39bad5df0>
template = '/tmp/pytest-of-ubuntu/pytest-648/test_api_invocation0/template'
output_dir = '/tmp/pytest-of-ubuntu/pytest-648/test_api_invocation0/output'
context = {'cookiecutter': {'email': 'raphael@hackebrot.de', 'full_name': 'Raphael Pierzina', 'github_username': 'hackebrot', 'version': '0.1.0'}}

    def test_api_invocation(mocker, template, output_dir, context):
        """Verify output dir location is correctly passed."""
        mock_gen_files = mocker.patch('cookiecutter.main.generate_files')
    
>       main.cookiecutter(template, output_dir=output_dir)

tests/test_specify_output_dir.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cookiecutter.main:88: in cookiecutter
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

context_file = '/tmp/pytest-of-ubuntu/pytest-648/test_api_invocation0/template/cookiecutter.json'
default_context = OrderedDict(), extra_context = None

    def generate_context(
        context_file='cookiecutter.json', default_context=None, extra_context=None
    ):
        """Generate the context for a Cookiecutter project template.
    
        Loads the JSON file as a Python object, with key being the JSON filename.
    
        :param context_file: JSON file containing key/value pairs for populating
            the cookiecutter's variables.
        :param default_context: Dictionary containing config to take into account.
        :param extra_context: Dictionary containing configuration overrides
        """
        context = OrderedDict([])
    
        try:
            with open(context_file, encoding='utf-8') as file_handle:
                obj = json.load(file_handle, object_pairs_hook=OrderedDict)
        except ValueError as e:
            # JSON decoding error.  Let's throw a new exception that is more
            # friendly for the developer or user.
            full_fpath = os.path.abspath(context_file)
            json_exc_message = str(e)
            our_exc_message = (
                'JSON decoding error while loading "{0}".  Decoding'
                ' error details: "{1}"'.format(full_fpath, json_exc_message)
            )
>           raise ContextDecodingException(our_exc_message)
E           cookiecutter.exceptions.ContextDecodingException: JSON decoding error while loading "/tmp/pytest-of-ubuntu/pytest-648/test_api_invocation0/template/cookiecutter.json".  Decoding error details: "Expecting value: line 1 column 1 (char 0)"

cookiecutter/generate.py:96: ContextDecodingException</pre>

<h3>Mutations</h3>
<ul>
    
    <li>LCR - line 55</li>
    
</ul>
<h3>Mutant</h3>
<pre class="brush: python; first-line: 1; highlight: [55]; toolbar: false;">'''
Main entry point for the `cookiecutter` command.

The code in this module is also a good example of how to use Cookiecutter as a
library rather than a script.
'''
import logging
import os

from cookiecutter.config import get_user_config
from cookiecutter.exceptions import InvalidModeException
from cookiecutter.generate import generate_context, generate_files
from cookiecutter.prompt import prompt_for_config
from cookiecutter.replay import dump, load
from cookiecutter.repository import determine_repo_dir
from cookiecutter.utils import rmtree

logger = logging.getLogger(__name__)


def cookiecutter(\
    template, \
    checkout=None, \
    no_input=False, \
    extra_context=None, \
    replay=None, \
    overwrite_if_exists=False, \
    output_dir='.', \
    config_file=None, \
    default_config=False, \
    password=None, \
    directory=None, \
    skip_if_file_exists=False, \
    accept_hooks=True):
    
    '''
    Run Cookiecutter just as if using it from the command line.

    :param template: A directory containing a project template directory,
        or a URL to a git repository.
    :param checkout: The branch, tag or commit ID to checkout after clone.
    :param no_input: Prompt the user at command line for manual configuration?
    :param extra_context: A dictionary of context that overrides default
        and user configuration.
    :param replay: Do not prompt for input, instead read from saved json. If
        ``True`` read from the ``replay_dir``.
        if it exists
    :param output_dir: Where to output the generated project dir into.
    :param config_file: User configuration file path.
    :param default_config: Use default values rather than a config file.
    :param password: The password to use when extracting the repository.
    :param directory: Relative path to a cookiecutter template in a repository.
    :param accept_hooks: Accept pre and post hooks if set to `True`.
    '''
    if (replay and (no_input is not False and extra_context is not None)):
        err_msg = \
            'You can not use both replay and no_input or extra_context at the same time.'
        
        
        raise InvalidModeException(err_msg)
    
    config_dict = get_user_config(config_file=\
        config_file, default_config=default_config)
    
    
    (repo_dir, cleanup) = determine_repo_dir(template=\
        template, abbreviations=\
        config_dict['abbreviations'], clone_to_dir=\
        config_dict['cookiecutters_dir'], checkout=\
        checkout, no_input=\
        no_input, password=\
        password, directory=\
        directory)
    
    
    template_name = os.path.basename(os.path.abspath(repo_dir))
    
    if replay:
        if isinstance(replay, bool):
            context = load(config_dict['replay_dir'], template_name)
        else:
            (path, template_name) = os.path.split(os.path.splitext(replay)[0])
            context = load(path, template_name)
    else:
        context_file = os.path.join(repo_dir, 'cookiecutter.json')
        logger.debug('context_file is %s', context_file)
        
        context = generate_context(context_file=\
            context_file, default_context=\
            config_dict['default_context'], extra_context=\
            extra_context)
        
        
        
        
        context['cookiecutter'] = prompt_for_config(context, no_input)
        
        
        context['cookiecutter']['_template'] = template
        
        
        context['cookiecutter']['_output_dir'] = os.path.abspath(output_dir)
        
        dump(config_dict['replay_dir'], template_name, context)
    
    
    result = generate_files(repo_dir=\
        repo_dir, context=\
        context, overwrite_if_exists=\
        overwrite_if_exists, skip_if_file_exists=\
        skip_if_file_exists, output_dir=\
        output_dir, accept_hooks=\
        accept_hooks)
    
    
    
    if cleanup:
        rmtree(repo_dir)
    
    return result</pre>

    </div>
</body>
</html>